[
    {
        "id": 1,
        "query": "XTop中针对5nm工艺的参数有哪些？",
        "Granularity1": "XTop FAQ\n\nQ6：5nm工艺，针对fix hold及leakage优化的setup derate如何设置比较合适？\nA：对于5nm工艺，相关的参数有`set_setup_extra_derate`, `pocvm_logic_depth_scale_factor`和`pocv_cell_delay_factor_transition_sigma`。\n为了保护setup 时序和精度，这些参数可以通过手动或者自动的办法设置。\n1. 手动设置时，通常按照下面的设置来收敛：\n···\nxtop > set_setup_extra_derate -scenario .*024_F2.* 1.14\t#低压corner, 0.55V\nxtop > set pocvm_logic_depth_scale_factor 0.5\t\t\t#POCV 的logic depth\nxtop > set pocv_cell_delay_factor_transition_sigma 1.5\t\t#如果有OCV sigma transitio\n···\n2. 自动设置时，需要设置parameter eco_auto_setup_extra_derate 为true，XTop 将自动进行检测，如果通过tlef\n或lef 文件发现当中具有7nm/5nm 相关联的标识rule，且存在有corner 对应\n的电压在0.7v 以下，工具将自动调整该corner 的derate 为1.05，同时，在进\n行leakage opt 时，工具将自动调整该corner 的derate 为1.02，具体为什么要\n调整为1.05 和1.02，通过历史bug 追踪，看到这是某些7nm/5nm 的工艺要\n求，暂时还不完全理解为什么需要这样设置",
        "Granularity2": "对于5nm工艺，相关的参数有`set_setup_extra_derate`, `pocvm_logic_depth_scale_factor`和`pocv_cell_delay_factor_transition_sigma`。\n为了保护setup 时序和精度，这些参数可以通过手动或者自动的办法设置。\n1. 手动设置时，通常按照下面的设置来收敛：\n···\nxtop > set_setup_extra_derate -scenario .*024_F2.* 1.14\t#低压corner, 0.55V\nxtop > set pocvm_logic_depth_scale_factor 0.5\t\t\t#POCV 的logic depth\nxtop > set pocv_cell_delay_factor_transition_sigma 1.5\t\t#如果有OCV sigma transitio\n···\n2. 自动设置时，需要设置parameter eco_auto_setup_extra_derate 为true，XTop 将自动进行检测，如果通过tlef\n或lef 文件发现当中具有7nm/5nm 相关联的标识rule，且存在有corner 对应\n的电压在0.7v 以下，工具将自动调整该corner 的derate 为1.05，同时，在进\n行leakage opt 时，工具将自动调整该corner 的derate 为1.02，具体为什么要\n调整为1.05 和1.02，通过历史bug 追踪，看到这是某些7nm/5nm 的工艺要\n求，暂时还不完全理解为什么需要这样设置",
        "Granularity3": "A：对于5nm工艺，相关的参数有`set_setup_extra_derate`, `pocvm_logic_depth_scale_factor`和`pocv_cell_delay_factor_transition_sigma`。\n为了保护setup 时序和精度，这些参数可以通过手动或者自动的办法设置。\n1. 手动设置时，通常按照下面的设置来收敛：\n···\nxtop > set_setup_extra_derate -scenario .*024_F2.* 1.14\t#低压corner, 0.55V\nxtop > set pocvm_logic_depth_scale_factor 0.5\t\t\t#POCV 的logic depth\nxtop > set pocv_cell_delay_factor_transition_sigma 1.5\t\t#如果有OCV sigma transitio\n···\n2. 自动设置时，需要设置parameter eco_auto_setup_extra_derate 为true，XTop 将自动进行检测",
        "Granularity4": "对于5nm工艺，相关的参数有`set_setup_extra_derate`, `pocvm_logic_depth_scale_factor`和`pocv_cell_delay_factor_transition_sigma`。\n为了保护setup 时序和精度，这些参数可以通过手动或者自动的办法设置。", 
        "Granularity5": "对于5nm工艺，相关的参数有`set_setup_extra_derate`, `pocvm_logic_depth_scale_factor`和`pocv_cell_delay_factor_transition_sigma`。", 
        "Granularity6": "set_setup_extra_derate, pocvm_logic_depth_scale_factor, pocv_cell_delay_factor_transition_sigma"   
    },
    {
        "id": 2,
        "query": "我想跑postmask eco流程，怎么做？",
        "Granularity1": "# Chapter 4. Optimize Design\n## Automatic ECO\n### Post-mask ECO\nPost-mask ECO \nPlease set the parameter eco_post_mask_mode to enable the post-mask eco mode. In \nlate stage of design, user may not want to change the mask to clean the timing. Post-\nmask ECO can help to do small changes to fix timing violations, by buffer insertion \nand cell sizing methods. It will only contain physical wire modification and avoid any \nplacement adjustment in the layout. Post-mask ECO supports spare cell flow and ga filler flow, and both flow supports manual eco and auto eco.\n\n#### Spare Cell Flow\nFor the spare cell flow, it just likes the usual eco flow, after enabling the post mask \nmode.  \n \nxtop> set_parameter  eco_post_mask_mode true \n \n##### for manual eco \nxtop> insert_buffer -design {regs} {dram1/C3/U574/C1} \n{OR4D0BWP12THVT} \nxtop> size_cell -design {DIU_MDI_0_test_1} {HDMIFF/U13} {CKBD8BWP12T} \n \n##### for auto eco \nxtop  set_parameter eco_buffer_list_for_hold  {AN2 OR2 BUF2 INV2} \nxtop> set_parameter eco_buffer_list_for_setup {AN2 OR2 BUF2} \nxtop> fix_setup/hold_gba_violation ...   \n\n#### GA filler Cell Flow\nFor the GA filler flow, please specify the parameter eco_ga_site or \neco_ga_name_pattern first. IMPORTANT NOTE: If both GA site and name pattern are defined, eco_ga_site will have the higher priority. In the optimization, XTop will delete the GA filler cells, \nand insert the new cells given, and use the GA filler cells to fill the blank space.  \n \nxtop> set_parameter eco_post_mask_mode true \nxtop> set_parameter eco_ga_site {gacore12T} \nxtop> set_parameter eco_ga_name_patterns {GFILL* GBUFF* GAN*} \nxtop> set_parameter eco_ga_filler_list {GFILL1BWP12T GFILL2BWP12T \nGFILL4BWP12T} \n \n##### for manual eco \nxtop> insert_buffer -design {regs} {dram1/xtop_cell_0/I} \n{GBUFFD1BWP12T} \\ \n      -locations {(190.200, 94.800)} size_cell \\ \n      -design {cpu} {dram_t2/C3/U392} {GMUX2ND1BWP12THVT} \n \n##### for auto eco \nxtop> set_parameter eco_buffer_list_for_hold  \\ \n           {GBUFFD1BWP12T GBUFFD4BWP12T GBUFFD8BWP12T} \nxtop> set_parameter eco_buffer_list_for_setup \\ \n           {GBUFFD1BWP12T GBUFFD4BWP12T GBUFFD8BWP12T} \nxtop> fix_setup/hold_gba_violations ...\n\n#### Please note:\n only insert_buffer and size_cell methods are supported in post mask mode.\nMore notes for the two different flows: \nFor spare cell flow:\n- fix_fanout_violations, fix_wire_length_violations and optimize_design_area commands are not supported in post mask mode.\n- in the buffer list parameter, not only allows buffer and inverter, but also support AND and OR cell.Currently, NAND, NOR and XOR cell are not supported.\n\nFor GA filler cell flow:\n- Parameter placement_legalization_mode is not working in post mask mode.\n- Supported cells include: buffer/inverter/and/or .\n- By default, only allow sizing from GA cells to GA cells. In 2020.06.sp1 or later, if user wants to size between GA cell and non-GA cells, please set parameter eco_ga_cell_sizing_rule to complete.",
        "Granularity2": "Post-mask ECO\nPost-mask ECO \nPlease set the parameter eco_post_mask_mode to enable the post-mask eco mode. In \nlate stage of design, user may not want to change the mask to clean the timing. Post-\nmask ECO can help to do small changes to fix timing violations, by buffer insertion \nand cell sizing methods. It will only contain physical wire modification and avoid any \nplacement adjustment in the layout. Post-mask ECO supports spare cell flow and ga filler flow, and both flow supports manual eco and auto eco.\n\n#### Spare Cell Flow\nxtop> set_parameter eco_post_mask_mode true \n\n##### for manual eco \nxtop> insert_buffer -design {regs} {dram1/C3/U574/C1} \n{OR4D0BWP12THVT} \nxtop> size_cell -design {DIU_MDI_0_test_1} {HDMIFF/U13} {CKBD8BWP12T} \n\n##### for auto eco \nxtop set_parameter eco_buffer_list_for_hold {AN2 OR2 BUF2 INV2} \nxtop> set_parameter eco_buffer_list_for_setup {AN2 OR2 BUF2} \nxtop> fix_setup/hold_gba_violation ... \n\n#### GA filler Cell Flow\nxtop> set_parameter eco_post_mask_mode true \nxtop> set_parameter eco_ga_site {gacore12T} \nxtop> set_parameter eco_ga_name_patterns {GFILL* GBUFF* GAN*} \nxtop> set_parameter eco_ga_filler_list {GFILL1BWP12T GFILL2BWP12T \nGFILL4BWP12T} \n\n##### for manual eco \nxtop> insert_buffer -design {regs} {dram1/xtop_cell_0/I} \n{GBUFFD1BWP12T} \\n -locations {(190.200, 94.800)} size_cell \\n -design {cpu} {dram_t2/C3/U392} {GMUX2ND1BWP12THVT} \n\n##### for auto eco \nxtop> set_parameter eco_buffer_list_for_hold \\n {GBUFFD1BWP12T GBUFFD4BWP12T GBUFFD8BWP12T} \nxtop> set_parameter eco_buffer_list_for_setup \\n {GBUFFD1BWP12T GBUFFD4BWP12T GBUFFD8BWP12T} \nxtop> fix_setup/hold_gba_violations ...\n\n#### Please note:\n only insert_buffer and size_cell methods are supported in post mask mode.",
        "Granularity3": "Please set the parameter eco_post_mask_mode to enable the post-mask eco mode.\n\n#### Spare Cell Flow\nxtop> set_parameter eco_post_mask_mode true \n\n##### for manual eco \nxtop> insert_buffer ...\nxtop> size_cell ...\n\n##### for auto eco \nxtop set_parameter eco_buffer_list_for_hold {AN2 OR2 BUF2 INV2} \nxtop> set_parameter eco_buffer_list_for_setup {AN2 OR2 BUF2} \nxtop> fix_setup/hold_gba_violation ... \n\n#### GA filler Cell Flow\nxtop> set_parameter eco_post_mask_mode true \nxtop> set_parameter eco_ga_site {gacore12T} \nxtop> set_parameter eco_ga_name_patterns {GFILL* GBUFF* GAN*} \nxtop> set_parameter eco_ga_filler_list {GFILL1BWP12T GFILL2BWP12T \nGFILL4BWP12T} \n\n##### for manual eco \nxtop> insert_buffer ...\nsize_cell ...\n\n##### for auto eco \nxtop> set_parameter eco_buffer_list_for_hold {GBUFFD1BWP12T GBUFFD4BWP12T GBUFFD8BWP12T} \nxtop> set_parameter eco_buffer_list_for_setup {GBUFFD1BWP12T GBUFFD4BWP12T GBUFFD8BWP12T} \nxtop> fix_setup/hold_gba_violations ...",
        "Granularity4": "Please set the parameter eco_post_mask_mode to enable the post-mask eco mode.\n\nxtop> set_parameter eco_post_mask_mode true \n\n##### for auto eco \nxtop set_parameter eco_buffer_list_for_hold {AN2 OR2 BUF2 INV2} \nxtop> set_parameter eco_buffer_list_for_setup {AN2 OR2 BUF2} \nxtop> fix_setup/hold_gba_violation ... \n\n##### for auto eco \nxtop> fix_setup/hold_gba_violations ...", 
        "Granularity5": "Please set the parameter eco_post_mask_mode to enable the post-mask eco mode.\nPost-\nmask ECO can help to do small changes to fix timing violations, by buffer insertion \nand cell sizing methods.\n\nxtop> set_parameter eco_post_mask_mode true \n\n#### Please note:\n only insert_buffer and size_cell methods are supported in post mask mode.", 
        "Granularity6": "Please set the parameter eco_post_mask_mode to enable the post-mask eco mode.\n\nxtop> set_parameter eco_post_mask_mode true"   
    },
    {
        "id": 3,
        "query": "turbo mode需要的sta data文件跟pro mode一样吗？",
        "Granularity1": "Xtop工具的优化模式特点\n1. Normal Mode: \n1) 基础的优化模式，数据导入速度和优化速度相对比较慢，但是读取数据不会有精度损失。\n\n2. Turbo Mode：\n1) Turbo Mode主要对导入数据的规模进行了优化，减少了获取的数据量，从而加速XTop数据文件导入的过程，减少内存损耗；\n2) 读取数据方面，Turbo Mode与Normal Mode的输入文件本身是一致的，但由于Turbo Mode读取输入文件时具体拿取的数据与Normal Mode存在不同，导致读取数据会有一定的精度损失，但Turbo Mode和Pro Mode在数据需求、数据拿取、数据精度方面完全一致；\n3) 提升优化速度，减少大型设计的内存损耗。\n\n3. Pro Mode：\n1) Pro Mode和Turbo Mode在除内存损耗以外的各项特性上基本相同，两者在输入文件、数据需求、数据拿取、数据精度、优化速度等方面基本无差别，因此，两者与Normal Mode相比都会有一定精度损失；\n2) Pro Mode与Turbo Mode唯一的不同点是在内存上的具体损耗有所不同。\n\n注意事项\n1) 当用户在Normal Mode下使用read_timing_data命令拿取数据时，如果使用了-memory_saving_mode选项，则会相当于切换到了Pro Mode，造成数据读取的精度损失。",
        "Granularity2": "Xtop工具的优化模式特点\n2. Turbo Mode：\n1) Turbo Mode主要对导入数据的规模进行了优化，减少了获取的数据量，从而加速XTop数据文件导入的过程，减少内存损耗；\n2) 读取数据方面，Turbo Mode与Normal Mode的输入文件本身是一致的，但由于Turbo Mode读取输入文件时具体拿取的数据与Normal Mode存在不同，导致读取数据会有一定的精度损失，但Turbo Mode和Pro Mode在数据需求、数据拿取、数据精度方面完全一致；\n3) 提升优化速度，减少大型设计的内存损耗。\n\n3. Pro Mode：\n1) Pro Mode和Turbo Mode在除内存损耗以外的各项特性上基本相同，两者在输入文件、数据需求、数据拿取、数据精度、优化速度等方面基本无差别，因此，两者与Normal Mode相比都会有一定精度损失；\n2) Pro Mode与Turbo Mode唯一的不同点是在内存上的具体损耗有所不同。\n\n注意事项\n1) 当用户在Normal Mode下使用read_timing_data命令拿取数据时，如果使用了-memory_saving_mode选项，则会相当于切换到了Pro Mode，造成数据读取的精度损失。",
        "Granularity3": "Turbo Mode：\n1) Turbo Mode主要对导入数据的规模进行了优化，减少了获取的数据量，从而加速XTop数据文件导入的过程，减少内存损耗；\n2) 读取数据方面，Turbo Mode与Normal Mode的输入文件本身是一致的，但由于Turbo Mode读取输入文件时具体拿取的数据与Normal Mode存在不同，导致读取数据会有一定的精度损失，但Turbo Mode和Pro Mode在数据需求、数据拿取、数据精度方面完全一致；\n3) 提升优化速度，减少大型设计的内存损耗。\n\n3. Pro Mode：\n1) Pro Mode和Turbo Mode在除内存损耗以外的各项特性上基本相同，两者在输入文件、数据需求、数据拿取、数据精度、优化速度等方面基本无差别，因此，两者与Normal Mode相比都会有一定精度损失；\n2) Pro Mode与Turbo Mode唯一的不同点是在内存上的具体损耗有所不同。",
        "Granularity4": "Turbo Mode：\n2) 读取数据方面，Turbo Mode与Normal Mode的输入文件本身是一致的，但由于Turbo Mode读取输入文件时具体拿取的数据与Normal Mode存在不同，导致读取数据会有一定的精度损失，但Turbo Mode和Pro Mode在数据需求、数据拿取、数据精度方面完全一致；\n\n3. Pro Mode：\n1) Pro Mode和Turbo Mode在除内存损耗以外的各项特性上基本相同，两者在输入文件、数据需求、数据拿取、数据精度、优化速度等方面基本无差别，因此，两者与Normal Mode相比都会有一定精度损失；", 
        "Granularity5": "读取数据方面，Turbo Mode与Normal Mode的输入文件本身是一致的，但由于Turbo Mode读取输入文件时具体拿取的数据与Normal Mode存在不同，导致读取数据会有一定的精度损失，但Turbo Mode和Pro Mode在数据需求、数据拿取、数据精度方面完全一致；", 
        "Granularity6": "读取数据方面，Turbo Mode与Normal Mode的输入文件本身是一致的"   
    },
    {
        "id": 4,
        "query": "修hold和leakage的时候，做size后，有的net因为原来就有si问题，导致size后的transition变大很多，带来了新的setup violation。希望如果某条net上已经有SI了就不要去换它的driver，怎么实现？",
        "Granularity1": "Parameters\n\nName\neco_si_critical_net_rank_ratio --What proportion of nets to be marked as si_critical net when fix hold or power.\n\nType\ntype: float \"[0,1]\"\n\nDefault\ndefault = \"0.05\"\n\nDescription\nThis parameter defines the proportion of si_critical nets. XTop will sort nets by worst max_delta_delay, select top worst nets and mark si_critical flag. When fix hold or optimize leakage/dynamic power, XTop will not size the driver of net. Use it when si is already bad before fixing hold or leakage.\n\nOnly works when fix hold or optimize power using size_cell method.\n\nOnly sort the net which has valid max_delta_delay.\n\nDo not mark net without valid max_delay_data, even the ratio is 1.\n\nUse the worst max_delta_delay from all valid setup scenarios.\n\nSort all nets of the design.\n\nWhen ratio is 0, no nets will be marked.\n\nWhen ratio is 1, all nets with valid max_delta_delay will be marked.\n\nDefault ratio is 0.05, please change it based on your design.\n\nExamples\nThe following example shows how to change the ratio.\n\n% set_parameter eco_si_critical_net_rank_ratio 0.1",
        "Granularity2": "Parameters\n\nName\neco_si_critical_net_rank_ratio --What proportion of nets to be marked as si_critical net when fix hold or power.\n\nDescription\nThis parameter defines the proportion of si_critical nets. XTop will sort nets by worst max_delta_delay, select top worst nets and mark si_critical flag. When fix hold or optimize leakage/dynamic power, XTop will not size the driver of net. Use it when si is already bad before fixing hold or leakage.\n\nOnly works when fix hold or optimize power using size_cell method.\n\nOnly sort the net which has valid max_delta_delay.\n\nDo not mark net without valid max_delay_data, even the ratio is 1.\n\nUse the worst max_delta_delay from all valid setup scenarios.\n\nSort all nets of the design.\n\nWhen ratio is 0, no nets will be marked.\n\nWhen ratio is 1, all nets with valid max_delta_delay will be marked.\n\nDefault ratio is 0.05, please change it based on your design.",
        "Granularity3": "Name\neco_si_critical_net_rank_ratio --What proportion of nets to be marked as si_critical net when fix hold or power.\n\nThis parameter defines the proportion of si_critical nets. XTop will sort nets by worst max_delta_delay, select top worst nets and mark si_critical flag. When fix hold or optimize leakage/dynamic power, XTop will not size the driver of net. Use it when si is already bad before fixing hold or leakage.\n\nOnly works when fix hold or optimize power using size_cell method.",
        "Granularity4": "XTop will sort nets by worst max_delta_delay, select top worst nets and mark si_critical flag. When fix hold or optimize leakage/dynamic power, XTop will not size the driver of net.", 
        "Granularity5": "When fix hold or optimize leakage/dynamic power, XTop will not size the driver of net.", 
        "Granularity6": "set_parameter eco_si_critical_net_rank_ratio 0.1"   
    },
    {
        "id": 5,
        "query": "size cell的时候cell会被挪动吗？",
        "Granularity1": "Commands\n\nName\nsize_cell --Size specified cell instances to the specified cell.\n\nSynopsis\nsize_cell [-design design_name] [-location coord...] cell_list lib_cell\n\nstring design\n\npointf location\n\ncollection cell_list\n\ncollection lib_cell\n\nArguments\n-design design_name Design for this action.\n\n-location... coord Location for the cell.\n\ncell_list Cells to size.\n\nlib_cell Library cell to size to.\n\nDescription\nThis command sizes the specified instances to the specified cell. It will first check if the specified instances\ncan be changed, and the specified master is legal.\n\nIf the placement legalization is on, it will try to find a correct place for the changed cell in the\nlegalization margin. If failed, by default, these cells will be put just at the specified positions, and it will\ngo on updating timing. If the placement legalization is an obligation, you can just turn the parameter\nplacement_legalization_obligated on. Thus if any cell failed to legalize, it will report an error and revert\nback.\n\nFor following situations, it will report errors.\n\n--Any of the library cells of the specified instances is not available.\n\n--Any of the timing library cells of specified instances is not complete for all corners.\n\n--The library for the specified cell is not available.\n\n--The timing library for the specified cell is not complete for all corners.\n\n--Any of the specified instances is not unique in Verilog.\n\n--Any of the specified instances is locked in placement.\n\n--Any of the specified instances is connected to a multi-driven net.\n\n--Function of the specified lib cell mismatches with original.\n\nThe following example size regs/dram1/U181/add_buf_4 to BUFFD12BTH, with user specified location.\n\n% size_cell -design {cpu} -location {(20.772, 179.597)} \\\n            {regs/dram1/U181/add_buf_4} {BUFFD12BTH}",
        "Granularity2": "Commands\n\nName\nsize_cell --Size specified cell instances to the specified cell.\n\nSynopsis\nsize_cell [-design design_name] [-location coord...] cell_list lib_cell\n\nArguments\n-design design_name Design for this action.\n\n-location... coord Location for the cell.\n\ncell_list Cells to size.\n\nlib_cell Library cell to size to.\n\nDescription\nThis command sizes the specified instances to the specified cell. It will first check if the specified instances\ncan be changed, and the specified master is legal.\n\nIf the placement legalization is on, it will try to find a correct place for the changed cell in the\nlegalization margin. If failed, by default, these cells will be put just at the specified positions, and it will\ngo on updating timing. If the placement legalization is an obligation, you can just turn the parameter\nplacement_legalization_obligated on. Thus if any cell failed to legalize, it will report an error and revert\nback.",
        "Granularity3": "If the placement legalization is on, it will try to find a correct place for the changed cell in the\nlegalization margin. If failed, by default, these cells will be put just at the specified positions, and it will\ngo on updating timing. If the placement legalization is an obligation, you can just turn the parameter\nplacement_legalization_obligated on. Thus if any cell failed to legalize, it will report an error and revert\nback.",
        "Granularity4": "If the placement legalization is on, it will try to find a correct place for the changed cell in the\nlegalization margin. If failed, by default, these cells will be put just at the specified positions, and it will\ngo on updating timing.",   
        "Granularity5": "If the placement legalization is on, it will try to find a correct place for the changed cell in the\nlegalization margin.",
        "Granularity6":  "try to find a correct place for the changed cell"
    },
    {
        "id": 6,
        "query": "std cell内部的blockage在GUI界面上为什么无法显示？",
        "Granularity1": "# 7 Appendix\nQ9: std cell 内部的blockage 在GUI 界面上为什么无法显\n示？ \nA： \n大体原因同7-Q9 一致. \n从一个ECO 工具的角度来说，GUI 只是帮助用户快速了解和明确，当前violati\non 点在layout 上的具体位置，\n及相关的net connection，\n这些已经足够用户进\n行manual eco 了，XTop 不是PR 工具，读入并存储太多对legal 影响不大的ph\nysical 信息，会导致工具内部的代码冗余，在用户端的表现也会呈现出越来越\n卡，综上所述，cell 内部blockage 对于pr tool 来说很重要但对ECO 工具来\n说，并无太大意义，故在读取数据时，工具会skip 这部分信息。 \n \n从实际使用的整体ECO 后向流程来说，在极个别情况下，也有可能因为XTop 看\n不到内部的blockage，而导致legal 阶段摆的cell 位置不是最优的，比如blo\nckage 包完后，只能左侧出pin，工具却将cell 挪到右侧，这样就增加了不必要\n的走线长度，\n增加pr rerouting 的时间，\n甚至会出现pin 绕线绕不出来的现象，\n但总体来说这种情况不多，eco 工具的首要目标还是在1-3 轮的迭代中，解决8\n0%以上的时序违例，同时在physical 层面保证不出现place 相关的DRC 问题，\n至于routing 相关，在pr tool 中做会更加有效。",
        "Granularity2": "# 7 Appendix\nQ9: std cell 内部的blockage 在GUI 界面上为什么无法显\n示？ \nA： \n大体原因同7-Q9 一致. \n从一个ECO 工具的角度来说，GUI 只是帮助用户快速了解和明确，当前violati\non 点在layout 上的具体位置，\n及相关的net connection，\n这些已经足够用户进\n行manual eco 了，XTop 不是PR 工具，读入并存储太多对legal 影响不大的ph\nysical 信息，会导致工具内部的代码冗余，在用户端的表现也会呈现出越来越\n卡，综上所述，cell 内部blockage 对于pr tool 来说很重要但对ECO 工具来\n说，并无太大意义，故在读取数据时，工具会skip 这部分信息。",
        "Granularity3": "从一个ECO 工具的角度来说，GUI 只是帮助用户快速了解和明确，当前violation 点在layout 上的具体位置，及相关的net connection，这些已经足够用户进行manual eco 了，XTop 不是PR 工具，读入并存储太多对legal 影响不大的physical 信息，会导致工具内部的代码冗余，在用户端的表现也会呈现出越来越卡，综上所述，cell 内部blockage 对于pr tool 来说很重要但对ECO 工具来说，并无太大意义，故在读取数据时，工具会skip 这部分信息。",
        "Granularity4": "XTop 不是PR 工具，读入并存储太多对legal 影响不大的physical 信息，会导致工具内部的代码冗余，在用户端的表现也会呈现出越来越卡，综上所述，cell 内部blockage 对于pr tool 来说很重要但对ECO 工具来说，并无太大意义，故在读取数据时，工具会skip 这部分信息。", 
        "Granularity5": "综上所述，cell 内部blockage 对于pr tool 来说很重要但对ECO 工具来说，并无太大意义，故在读取数据时，工具会skip 这部分信息。", 
        "Granularity6": "工具会skip 这部分信息。"   
    },
    {
        "id": 7,
        "query": "xtop读入timing data hang住了？",
        "Granularity1": "# 6 General Usage\nQ5: 工具没内存hang 住，而cache memory 得不到释放怎么\n办？ \nA：但跑大规模的例子的时候，会出现由于内存不够，工具hang 的情况。而用\ntop 命令去报告，有很多cache memory 得不到释放，导致工具可用的free \nmemory 不够。 \n% free -m   (可查看当前内存使用情况) \n \n需要联系客户的IT 部门，管理员权限，进行下面的硬件调整方案： \n1. 建议 min_free_kbytes 设置为系統内存的5％，临时命令为cat 27033600 > \n/proc/sys/vm/min_free_kbytes，系统重启后恢复原值 \n2. 最好设置 sysctl -w vm.swappiness＝5，这个的用途是尽可能让系统把 \ncached 的memory 释放到free memory 里面去 \n3. 如果有可能，可以给server 挂一个SSD 的硬盘作为swap 空间，万一用到\nswap 区域，也会更快地swap \n当XTop 在读 timing data 的时候容易hang 住，根本原因在于Linux 的内存分\n为三级，free/cached/swap memory， \n程序总是使用 free memory，而系统不断的把 cached memory release 到free \nmemory; \n当free memory 设置较少的时候，系统没有按照XTop 的实际需求把 cached \nmemory 释放到free memory，而是一点点的释放， \n这样就不足与支撑大量timing data，就看起来hang 住了。 \n缓解这个hang 住的方案就是把free memory 设的足够大，能够支持大量读入\ntiming data，然后系统度不断的释放cached memory 到 free memory， \n这样虽然不能够跟free memory 足够的时候那种全速，但也可以高速的读数据，\n解决hang 住的问题。",
        "Granularity2": "# 6 General Usage\nQ5: 工具没内存hang 住，而cache memory 得不到释放怎么\n办？ \nA：但跑大规模的例子的时候，会出现由于内存不够，工具hang 的情况。而用\ntop 命令去报告，有很多cache memory 得不到释放，导致工具可用的free \nmemory 不够。 \n% free -m   (可查看当前内存使用情况) \n \n需要联系客户的IT 部门，管理员权限，进行下面的硬件调整方案： \n当XTop 在读 timing data 的时候容易hang 住，根本原因在于Linux 的内存分\n为三级，free/cached/swap memory， \n程序总是使用 free memory，而系统不断的把 cached memory release 到free \nmemory; \n当free memory 设置较少的时候，系统没有按照XTop 的实际需求把 cached \nmemory 释放到free memory，而是一点点的释放， \n这样就不足与支撑大量timing data，就看起来hang 住了。 \n缓解这个hang 住的方案就是把free memory 设的足够大，能够支持大量读入\ntiming data，然后系统度不断的释放cached memory 到 free memory， \n这样虽然不能够跟free memory 足够的时候那种全速，但也可以高速的读数据，\n解决hang 住的问题。",
        "Granularity3": "为三级，free/cached/swap memory， \n程序总是使用 free memory，而系统不断的把 cached memory release 到free \nmemory; \n当free memory 设置较少的时候，系统没有按照XTop 的实际需求把 cached \nmemory 释放到free memory，而是一点点的释放， \n这样就不足与支撑大量timing data，就看起来hang 住了。",
        "Granularity4": "缓解这个hang 住的方案就是把free memory 设的足够大，能够支持大量读入\ntiming data，然后系统度不断的释放cached memory 到 free memory， \n这样虽然不能够跟free memory 足够的时候那种全速，但也可以高速的读数据，\n解决hang 住的问题。", 
        "Granularity5": "缓解这个hang 住的方案就是把free memory 设的足够大，能够支持大量读入\ntiming data", 
        "Granularity6": "把free memory 设的足够大"   
    },
    {
        "id": 8,
        "query": "power intent cells如何定义？用UPF命令和在.lib文件都可以定义吗？",
        "Granularity1": "\n\n首先，XTop 支持用UPF 命令去设置某些cell 为power intent cell（包括iso, \nlevel shifter, power-switch, repeater, retention cell 等）：\nset_isolation xx -domain PD_X ...\nmap_isolation_cell xx  -domain PD_X  -lib_cells {lib_cell_list}  \n...\n其次，XTop 也从lib 里拿iso/level shifter/always-on 等信息，而且和从UPF\n中拿power intent cell 信息，不分先后，互不影响。\n\npower intent cells可以通过UPF命令来定义，比如使用set_isolation, map_isolation_cell, set_level_shifter, map_level_shifter_cell等命令来设置不同的power intent cell类型。同时，XTop也能从.lib文件中识别出iso、level shifter、always-on等类型的power intent cells，表明这两种方式均可用于定义power intent cells，且相互独立，互不影响。\n\n综上所述，power intent cells既可以通过UPF命令进行详细定义，也可以在.lib文件中定义，XTop支持并能够识别这两种方式定义的power intent cells。",
        "Granularity2": "\n\n首先，XTop 支持用UPF 命令去设置某些cell 为power intent cell（包括iso, \nlevel shifter, power-switch, repeater, retention cell 等）：\nset_isolation xx -domain PD_X ...\nmap_isolation_cell xx  -domain PD_X  -lib_cells {lib_cell_list}  \n...\n其次，XTop 也从lib 里拿iso/level shifter/always-on 等信息，而且和从UPF\n中拿power intent cell 信息，不分先后，互不影响。",
        "Granularity3": "首先，XTop 支持用UPF 命令去设置某些cell 为power intent cell（包括iso, \nlevel shifter, power-switch, repeater, retention cell 等）：\n...\n其次，XTop 也从lib 里拿iso/level shifter/always-on 等信息，而且和从UPF\n中拿power intent cell 信息，不分先后，互不影响。",
        "Granularity4": "XTop 支持用UPF 命令去设置某些cell 为power intent cell（包括iso, \nlevel shifter, power-switch, repeater, retention cell 等）：\n...\nXTop 也从lib 里拿iso/level shifter/always-on 等信息", 
        "Granularity5": "XTop 支持用UPF 命令去设置某些cell 为power intent cell\nXTop 也从lib 里拿iso/level shifter/always-on 等信息", 
        "Granularity6": "UPF 命令去设置某些cell 为power intent cell"  
    },
    {
        "id": 9,
        "query": "Set_module_dont_touch和set_hier_path_dont_touch的区别？",
        "Granularity1": "# 3 Parameter参数\nQ1：don't_touch 设置在cell/pin/net/path 上有什么区别？ \nA： don't_touch 可以设置在cell, net, pin, path 和library cell 等对象上。 \n    这里的pin 有些特殊，\n因为它们代表连接关系，\n并不是design 中真实的objects，\n只是用来控制工具在优化过程中的扫描点，基于debug 的目的。 \n⚫ 对于cell/net，\n如果设定了don't_touch，\n就不会在相应的单元/线网上做eco 动\n作。 \n⚫ 对于library cell，\ndon't_touch 意味着库中的所有该单元的实例，\n都don't_touch\n了。 \n⚫ 对于pin，如果设定了don't_touch，在时序优化的扫描过程中就会跳过这个\n点。 （譬如，后果是不会在它上插buffer 的） \n⚫ 对于path，如果设定了don't_touch，在扫描过程中就会跳过path 上的所有\npin。 \n另外，需要注意： \nset_module_dont_touch $ref_name       \n相当于把该ref_name 对应的module 内部所有的cell，net 和pin 都dont touch \nset_hier_path_dont_touch $hier_path    \n相当于把该hier_path 下所有的cell，net 和pin 都dont touch 了； \n在hierarchy pin 上设dont_touch 无效（它并不是实体，不参与扫描）； \n在hierarchy net 上设dont_touch 有效（它对应着top net 实体）。",
        "Granularity2": "另外，需要注意： \nset_module_dont_touch $ref_name       \n相当于把该ref_name 对应的module 内部所有的cell，net 和pin 都dont touch \nset_hier_path_dont_touch $hier_path    \n相当于把该hier_path 下所有的cell，net 和pin 都dont touch 了； \n在hierarchy pin 上设dont_touch 无效（它并不是实体，不参与扫描）； \n在hierarchy net 上设dont_touch 有效（它对应着top net 实体）。",
        "Granularity3": "set_module_dont_touch $ref_name       \n相当于把该ref_name 对应的module 内部所有的cell，net 和pin 都dont touch \nset_hier_path_dont_touch $hier_path    \n相当于把该hier_path 下所有的cell，net 和pin 都dont touch 了； \n在hierarchy pin 上设dont_touch 无效（它并不是实体，不参与扫描）",
        "Granularity4": "set_module_dont_touch $ref_name       \n相当于把该ref_name 对应的module 内部所有的cell，net 和pin 都dont touch \nset_hier_path_dont_touch $hier_path    \n相当于把该hier_path 下所有的cell，net 和pin 都dont touch 了", 
        "Granularity5": "set_module_dont_touch $ref_name       \n相当于把该ref_name 对应的module 内部所有的cell，net 和pin 都dont touch \nset_hier_path_dont_touch $hier_path", 
        "Granularity6": "相当于把该hier_path 下所有的cell，net 和pin 都dont touch 了；"   
    },
    {
        "id": 10,
        "query": "如何加快sta data preparation的速度，以及减少sta data size？",
        "Granularity1": "Arguments\n-hold_uncovered hold_limit Also print uncovered hold violated pins for current selected scenarios.\n\n-setup_uncovered setup_limit Also print uncovered setup violated pins for current selected scenarios.\n\nDescription\nWhen this command is called, XTop read GBA slacks and rail voltage(optional) from all scenarios, and some top scenarios with worst end point violation are picked out according to user's input. When read_timing_data is called, only the timing data of scenarios in that list will be read, so memory usage and runtime will be decreased. User can call this command repeatedly with different input to get a wanted result, and use reduce_scenario to implement the behavior.\n\nCommand report_dropped_scenarios can be called to report scenarios that are dropped by reduce_scenario. If this command is called again after a valid redution, \"top_n\" and \"coverage\" will be calculated according to latest scenarios, and timing data will also be read again.\n\nSkipped scenario setting will be honored in reduction.\n\nThe command must be called before read_timing_data and after build_timing_graph.",
        "Granularity2": "Description\nWhen this command is called, XTop read GBA slacks and rail voltage(optional) from all scenarios, and some top scenarios with worst end point violation are picked out according to user's input. When read_timing_data is called, only the timing data of scenarios in that list will be read, so memory usage and runtime will be decreased. User can call this command repeatedly with different input to get a wanted result, and use reduce_scenario to implement the behavior.\n\nCommand report_dropped_scenarios can be called to report scenarios that are dropped by reduce_scenario. If this command is called again after a valid redution, \"top_n\" and \"coverage\" will be calculated according to latest scenarios, and timing data will also be read again.\n\nSkipped scenario setting will be honored in reduction.\n\nThe command must be called before read_timing_data and after build_timing_graph.",
        "Granularity3": "When this command is called, XTop read GBA slacks and rail voltage(optional) from all scenarios, and some top scenarios with worst end point violation are picked out according to user's input. When read_timing_data is called, only the timing data of scenarios in that list will be read, so memory usage and runtime will be decreased.",
        "Granularity4": "When read_timing_data is called, only the timing data of scenarios in that list will be read, so memory usage and runtime will be decreased.", 
        "Granularity5": "User can call this command repeatedly with different input to get a wanted result, and use reduce_scenario to implement the behavior.", 
        "Granularity6": "only the timing data of scenarios in that list will be read, so memory usage and runtime will be decreased."   
    }
]